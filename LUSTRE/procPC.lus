include "memoire.lus"

--------------------------------------------------------------------------
-- PARTIE CONTROLE DU PROCESSEUR JOUET
--
-- on sort les etats pour visualisation

-- Etat[0]: reset PC
-------resetPC

-- Etat[1]: RI1=mem[PC] et PC=PC+1
-------OpUAL1,OpUAL0= 0, 1
-------chPC, chRI1,
-------PC sur BusAdresse : SelBusAd=1
------ SelBusOp11,SelBusOp10= 0,1

-- Etat[2]: RI2=mem[PC] et PC=PC+1
-------OpUAL1,OpUAL0= 0, 1
-------chPC, chRI2,
-------PC sur BusAdresse : SelBusAd=1
------ SelBusOp11,SelBusOp10= 0,1

-- Etat[3]: ACC=RI2
-------chACC
------ SelBusOp11,SelBusOp10= 0,0
-------OpUAL1,OpUAL0= 1, 0

-- Etat[4]: mem[RI2]=ACC
--------RI2 sur BusAdresse : SelBusAd=0
--------write
--------ACC est toujours sur BusDonSort

-- Etat[5]: ACC=ACC+mem[RI2]
-------chACC
-------RI2 sur BusAdresse : SelBusAd=0
-------OpUAL1,OpUAL0= 0, 0
-------SelBusOp11,SelBusOp10=1,0
-------SelBusOp2= BusDonEnt = 0
-------BusDonEnt toujours relie à la memoire en lecture

-- Etat[6]: PC=RI2
-------chPC
-------OpUAL1,OpUAL0= 1, 0
-------SelBusOp11,SelBusOp10=0,0

----------------------------------------------------------------------------
node processeurPC  (reset:bool; RI1012:bool^3) -- MODIF avant c'était RI101:bool^2
returns(SelBusOp11,SelBusOp10,SelBusOp2,SelBusAd,chRI1, chRI2, chPC,chACC,OpUAL1,OpUAL0,resetPC, write, chFlag:bool;
----Pour le debug
Etat:bool^8; -- MODIF : ajout d'un nouvel état.
);
var
--Etat:bool^7;
EtatSuiv:bool^8; -- MODIF : ajout d'un nouvel état.

let
-----Memorisation de l'etat courant
Etat[0]=bascule(EtatSuiv[0],true,false,reset); --etat initial mise a 1 au moment du reset
Etat[1..7]=map<<bascule,7>>(EtatSuiv[1..7],true^7,reset^7,false^7); --MODIF: ajout d'un nouvel état.

------Calcul de l'etat suivant
EtatSuiv[0]=false;
-- retour au fetch1 après n'importe quel état de commande
EtatSuiv[1]=Etat[0] or Etat[3] or Etat[4] or Etat[5] or Etat[6] or Etat[7]; -- MODIF : ajout d'un nouvel état.
EtatSuiv[2]=Etat[1];
-- décode 2 bits pour LOAD/STORE/ADD
EtatSuiv[3]=(not RI1012[0]) and (not RI1012[1]) and Etat[2]; --LOAD
EtatSuiv[4]= RI1012[0] and (not RI1012[1]) and Etat[2]; --STORE
EtatSuiv[5]=(not RI1012[0]) and  RI1012[1] and Etat[2]; --ADD
-- decode JUMP vs SUB selon 3eme bit.
EtatSuiv[6]= RI1012[0] and  RI1012[1] and (not RI1012[2]) and Etat[2]; --JUMP
EtatSuiv[7]= RI1012[0] and  RI1012[1] and  RI1012[2] and Etat[2]; --SUB

-------Calcul des sorties (commandes de la PO)
------Chargement des registres
resetPC=Etat[0];
chPC=Etat[1] or Etat[2] or Etat[6]; -- on n'incrémente pas le PC en SUB.
chACC=Etat[3] or Etat[5] or Etat[7]; -- charger ACC pour ADD et SUB

-- nouveau : on mémorise les flags seulement lors d’une instruction de calcul
chFlag = Etat[5] or Etat[7];               -- 5=ADD, 7=SUB

chRI1=Etat[1];
chRI2=Etat[2];

-------Selection des Bus
SelBusOp11=Etat[5] or Etat[7]; --operand1 = ACC pour ADD/SUB
SelBusOp10=Etat[1] or Etat[2];
SelBusOp2=false; -- mém. pour ADD/SUB
SelBusAd=Etat[1] or Etat[2];

------Operation UAL
OpUAL1=Etat[3] or Etat[6] or Etat[7]; -- SUB active aussi bit1
OpUAL0=Etat[1] or Etat[2] or Etat[7]; --SUB active aussi bit0

-----Ecriture memoire
write=Etat[4];
tel;


